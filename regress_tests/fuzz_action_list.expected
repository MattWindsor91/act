fetch.make.int.dead:
  Weight: 20x
  Summary:
    Generates a fetch operation on a randomly selected fuzzer-generated
    global variable.
    
    This variant can target any source and destination, but only inserts into
    dead code. As it only targets dead code, it does not add dependences or
    erase known-values.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
fetch.make.int.redundant:
  Weight: 20x
  Summary:
    Generates a fetch operation on a randomly selected fuzzer-generated
    global variable.
    
    This variant can insert anywhere, but only fetchs the known value of a
    destination back to itself.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
flow.dead.early-out:
  Weight: 20x
  Summary:
    Inserts a valid 'early-out' statement (break or return) into a random
    dead-code location.
flow.dead.goto:
  Weight: 20x
  Summary:
    Inserts a jump to a random thread-local label inside a dead-code
    block.
    
    This action only fires in dead-code blocks for which there are available
    labels in the same thread; it does not jump outside the thread.
flow.if.duplicate:
  Weight: 15x
  Summary:
    Removes a sublist of statements from the program, replacing them with an
    `if` statement containing some transformation of the removed
    statements.
    
    This version of the action generates an arbitrary condition, and
    initialises both branches of the `if` statement with the original
    statements. It cannot fire if the statements contain any labels, to avoid
    duplicating them.
flow.if.tautology:
  Weight: 25x
  Summary:
    Removes a sublist of statements from the program, replacing them with an
    `if` statement containing some transformation of the removed
    statements.
    
    This version of the action generates an always-true condition, puts the
    original statements in the true block, and marks the false block as
    dead-code.
flow.invert-if:
  Weight: 10x
  Summary: Flips the conditional and branches of an if statement.
flow.loop.surround:
  Weight: 20x
  Summary:
    Removes a sublist of statements from the program, replacing them with a
    `do... while` statement containing some transformation of the removed
    statements.
    
    The condition of the `do... while` loop is statically guaranteed to be
    false.
mem.fence:
  Weight: 15x
  Summary: Inserts a randomly generated memory fence into the test.
mem.strengthen:
  Weight: 15x
  Summary:
    Replaces the memory order of a random atomic statement (not an atomic
    expression) with another memory order.
    
    Usually, this will only perform the replacement when the new memory order
    is compatible with the atomic action and also stronger than the old one.
    If 'mem.unsafe-weaken-orders' is true, this action will permit weakening
    of memory orders, likely resulting in a loss of semantics preservation.
program.label:
  Weight: 15x
  Summary: Inserts a new, random label into the program.
program.make.empty:
  Weight: 10x
  Summary:
    Generates a new, empty program at one end of the program list. This
    action isn't very useful on its own, but works well in combination with
    other actions that construct statements and control flows.
store.make.int.dead:
  Weight: 20x
  Summary:
    Generates a store operation on a randomly selected fuzzer-generated
    global variable.
    
    This variant can target any source and destination, but only inserts into
    dead code. As it only targets dead code, it does not add dependences or
    erase known-values.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
store.make.int.normal:
  Weight: 30x
  Summary:
    Generates a store operation on a randomly selected fuzzer-generated
    global variable.
    
    This variant can insert anywhere and target any source and
    destination.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
store.make.int.redundant:
  Weight: 15x
  Summary:
    Generates a store operation on a randomly selected fuzzer-generated
    global variable.
    
    This variant can insert anywhere, but only stores the known value of a
    destination back to itself.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
var.make:
  Weight: 20x
  Summary:
    Generates a new variable, with a random name, initial value, and
    primitive type.
    
    If the 'var.make.global' flag is set, the variable will be global; else,
    it'll be a local variable assigned to a random thread.
