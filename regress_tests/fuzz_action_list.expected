atomic.cmpxchg.insert.int.succeed:
  Weight: 30x
  Summary:
    Inserts an atomic int compare-exchange that always succeeds, and a new
    local Boolean variable that receives its result.
    
    This compare-exchange guarantees static success by storing the known
    value of a variable to another fresh variable, then using that as the
    'expected' value.
    
    The new variable is set up such that it has a known value of 'true'.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
atomic.fetch.insert.int.dead:
  Weight: 20x
  Summary:
    Generates a fetch operation on a randomly selected fuzzer-generated
    global variable.
    
    This variant can target any source and destination, but only inserts into
    dead code. As it only targets dead code, it does not add dependences or
    erase known-values.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
atomic.fetch.insert.int.redundant:
  Weight: 20x
  Summary:
    Generates a fetch operation on a randomly selected fuzzer-generated
    global variable.
    
    This variant can insert anywhere, but only fetches the known value of a
    destination back to itself.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
atomic.store.insert.int.dead:
  Weight: 20x
  Summary:
    Generates a store operation on a randomly selected fuzzer-generated
    global atomic variable.
    
    This variant can target any source and destination, but only inserts into
    dead code. As it only targets dead code, it does not add dependences or
    erase known-values.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
atomic.store.insert.int.normal:
  Weight: 20x
  Summary:
    Generates a store operation on a randomly selected fuzzer-generated
    global atomic variable.
    
    This variant can insert anywhere and target any source and
    destination.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
atomic.store.insert.int.redundant:
  Weight: 15x
  Summary:
    Generates a store operation on a randomly selected fuzzer-generated
    global atomic variable.
    
    This variant can insert anywhere, but only stores the known value of a
    destination back to itself.
    
    This operation generates 'atomic_int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
atomic.store.transform.xchgify:
  Weight: 15x
  Summary:
    Promotes a random atomic store to an atomic exchange whose value is
    discarded.
flow.dead.insert.early-out:
  Weight: 20x
  Summary:
    Inserts a valid 'early-out' statement (break or return) into a random
    dead-code location.
flow.dead.insert.goto:
  Weight: 20x
  Summary:
    Inserts a jump to a random thread-local label inside a dead-code
    block.
    
    This action only fires in dead-code blocks for which there are available
    labels in the same thread; it does not jump outside the thread.
flow.if.surround.duplicate:
  Weight: 15x
  Summary:
    Removes a sublist of statements from the program, replacing them with an
    `if` statement containing some transformation of the removed
    statements.
    
    This version of the action generates an arbitrary condition, and
    initialises both branches of the `if` statement with the original
    statements. It cannot fire if the statements contain any labels, to avoid
    duplicating them.
flow.if.surround.tautology:
  Weight: 15x
  Summary:
    Removes a sublist of statements from the program, replacing them with an
    `if` statement containing some transformation of the removed
    statements.
    
    This version of the action generates an always-true condition, puts the
    original statements in the true block, and marks the false block as
    dead-code.
flow.if.transform.invert:
  Weight: 10x
  Summary: Flips the conditional and branches of an if statement.
flow.lock.surround.atomic:
  Weight: disabled
  Summary:
    This action removes a sublist of statements from the program, replacing
    them with an atomic block containing those statements.
flow.lock.surround.sync:
  Weight: disabled
  Summary:
    This action removes a sublist of statements from the program, replacing
    them with a synchronised block containing those statements.
flow.loop.insert.while.false:
  Weight: 15x
  Summary:
    Inserts an empty while loop whose condition is known to be false, and
    whose body is marked as dead-code for future actions.
flow.loop.surround.do.dead:
  Weight: 10x
  Summary:
    This action removes a sublist of statements from the program, replacing
    them with do loops containing those statements.
    
    This action will only surround portions of dead code, but the condition
    of the `do... while` loop can be anything.
flow.loop.surround.do.false:
  Weight: 15x
  Summary:
    This action removes a sublist of statements from the program, replacing
    them with do loops containing those statements.
    
    The condition of the `do... while` loop is statically guaranteed to be
    false, meaning the loop will iterate only once.
flow.loop.surround.for.once-kv:
  Weight: 15x
  Summary:
    This action removes a sublist of statements from the program, replacing
    them with for-loops containing those statements.
    
    The for loop initialises its (fresh) counter to the known value of an
    existing variable and compares it in such a way as to execute only once.
flow.loop.surround.for.simple:
  Weight: 15x
  Summary:
    This action removes a sublist of statements from the program, replacing
    them with for-loops containing those statements.
    
    The for loop initialises its (fresh) counter to zero, then counts upwards
    to a random, small, constant value. This action does not surround
    non-generated or loop-unsafe statements.
flow.loop.surround.while.dead:
  Weight: 10x
  Summary:
    This action removes a sublist of statements from the program, replacing
    them with while loops containing those statements.
    
    This action will only surround portions of dead code, but the condition
    of the `while` loop can be anything.
mem.fence:
  Weight: 15x
  Summary: Inserts a randomly generated memory fence into the test.
mem.strengthen:
  Weight: 15x
  Summary:
    Replaces the memory order of a random atomic statement (not an atomic
    expression) with another memory order.
    
    Usually, this will only perform the replacement when the new memory order
    is compatible with the atomic action and also stronger than the old one.
    If 'mem.unsafe-weaken-orders' is true, this action will permit weakening
    of memory orders, likely resulting in a loss of semantics preservation.
program.label:
  Weight: 15x
  Summary: Inserts a new, random label into the program.
program.make.empty:
  Weight: 10x
  Summary:
    Generates a new, empty program at one end of the program list. This
    action isn't very useful on its own, but works well in combination with
    other actions that construct statements and control flows.
var.assign.insert.int.dead:
  Weight: 20x
  Summary:
    Generates an assign operation on a randomly selected fuzzer-generated
    variable.
    
    This variant can target any source and destination, but only inserts into
    dead code. As it only targets dead code, it does not add dependences or
    erase known-values.
    
    This operation generates 'int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
var.assign.insert.int.normal:
  Weight: 20x
  Summary:
    Generates an assign operation on a randomly selected fuzzer-generated
    variable.
    
    This variant can insert anywhere and target any source and
    destination.
    
    This operation generates 'int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
var.assign.insert.int.redundant:
  Weight: 15x
  Summary:
    Generates an assign operation on a randomly selected fuzzer-generated
    variable.
    
    This variant can insert anywhere, but only stores the known value of a
    destination back to itself.
    
    This operation generates 'int's.
    
    If 'store.forbid-already-written' is true, this action will only store to
    variables that haven't previously been selected for store actions. This
    makes calculating candidate executions easier, but limits the degree of
    entropy somewhat. (Note that if the value is stochastic, the action will
    only fire if such variables exist, but may or may not proceed to select a
    previously-stored variable. This is a limitation of the flag system.)
var.make:
  Weight: 20x
  Summary:
    Generates a new variable, with a random name, initial value, and
    primitive type.
    
    If the 'var.make.global' flag is set, the variable will be global; else,
    it'll be a local variable assigned to a random thread.
var.volatile:
  Weight: 25x
  Summary: Adds the 'volatile' qualifier to a local variable.
