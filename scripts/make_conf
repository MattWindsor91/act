#!/usr/bin/env python3

"""Automatically generates an act.conf for the local machine and puts it on stdout."""

import collections
import enum
import itertools
import platform
import subprocess
import typing
from dataclasses import dataclass
from datetime import datetime


class Target(enum.Enum):
    """Enumeration of target IDs supported in act.conf 'arch' directives."""

    X64_ATT = "x64.att"
    X86_ATT = "x86.att"

    @property
    def short_name(self) -> str:
        """The most significant part of the target's ID."""
        (sn, _, _) = self.value.partition(".")
        return sn

    def force_32bit(self, arch: str) -> bool:
        """Tests whether 32-bit mode needs to be forced in a compiler."""
        return self is Target.X86_ATT and arch == "x86_64"


gcc_like_compilers = ["gcc", "clang"]
olevels = [0, 3]

gcc_targets_of_arch = {
    "x86_64": [Target.X86_ATT, Target.X64_ATT],
    "i386": [Target.X86_ATT],
}

herdtools_backends = {"herd": ["herd", "herd7"], "litmus": ["litmus", "litmus7"]}


@dataclass
class Compiler:
    """Information about a compiler on an ACT target machine."""

    style: str
    target: Target
    cmd: str
    args: typing.List[str]

    @property
    def args_str(self) -> str:
        return " ".join((f'"{a}"' for a in self.args))

    def print(self) -> None:
        print(f"        style {self.style}")
        print(f"        arch  {self.target.value}")
        print(f'        cmd   "{self.cmd}"')
        print(f"        argv  {self.args_str}")


@dataclass
class Backend:
    """Information about a backend on an ACT target machine."""

    style: str
    cmd: str

    def print(self) -> None:
        print(f"        style {self.style}")
        print(f'        cmd   "{self.cmd}"')


@dataclass
class Machine:
    """Information about an ACT target machine."""

    id: str
    arch: str
    compilers: typing.Mapping[str, Compiler]
    backends: typing.Mapping[str, Backend]

    def print_compilers(self) -> None:
        for (key, val) in self.compilers.items():
            print(f"    compiler {key} {{")
            val.print()
            print("    }")

    def print_backends(self) -> None:
        for (key, val) in self.backends.items():
            print(f"    sim {key} {{")
            val.print()
            print("    }")

    def print_header(self) -> None:
        print(f"# Auto-generated act.conf for '{self.id}' (architecture {self.arch}).")
        print(f"# Generated on {datetime.today()}.")

    def print(self) -> None:
        self.print_header()
        print(f"machine {self.id} {{")
        print("    via local")
        self.print_compilers()
        self.print_backends()
        print("}")


nodetrans = str.maketrans("-", "_")


def trim_node(full_node: str) -> str:
    (node_prefix, _, _) = full_node.partition(".")
    return node_prefix.translate(nodetrans)


def gcc_args(arch: str, target: Target, olevel: int) -> typing.Iterator[str]:
    if target.force_32bit(arch):
        yield "-m32"
    if olevel != 0:
        yield f"-O{olevel}"
    yield "-DNO_PTHREADS"


def command_works(cmd: str, *args: str) -> bool:
    """Runs the given command with the given argument list, and returns whether
    it succeeded.
    """
    try:
        test: subprocess.CompletedProcess = subprocess.run(
            [cmd, *args], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        return test.returncode == 0
    except FileNotFoundError:
        # Assume this is a missing program
        return False


def gcc_like_compiler_stanza(
    cmd: str, arch: str, target: Target, olevel: int
) -> Compiler:
    """Emits a compiler stanza for a particular O-level of a GCC-like compiler.
    Assumes that the compiler has already been checked.
    """
    args = list(gcc_args(arch, target, olevel))
    return Compiler(style="gcc", target=target, cmd=cmd, args=args)


def gcc_like_compiler_stanzas(
    cmd: str, arch: str
) -> typing.Iterator[typing.Tuple[str, Compiler]]:
    """Emits a set of compiler stanzas for a particular GCC-like compiler.
    Assumes that the compiler has already been checked.
    """
    targets = gcc_targets_of_arch[arch]
    for (target, olevel) in itertools.product(targets, olevels):
        id = ".".join([cmd, target.short_name, f"O{olevel}"])
        compiler = gcc_like_compiler_stanza(cmd, arch, target, olevel)
        yield (id, compiler)


def lookup_gcc_like_compiler(cmd: str, arch: str) -> typing.Mapping[str, Compiler]:
    """Tests to see if the named GCC-like compiler exists.
    If so, emits a dictionary containing one or more stanzas for it.
    If not, emits an empty dictionary.
    """
    return (
        dict(gcc_like_compiler_stanzas(cmd, arch))
        if command_works(cmd, "--version")
        else {}
    )


def lookup_gcc_like_compilers(arch: str) -> typing.Mapping[str, Compiler]:
    return collections.ChainMap(
        *(lookup_gcc_like_compiler(cmd, arch) for cmd in gcc_like_compilers)
    )


def lookup_local_compilers(arch: str) -> typing.Mapping[str, Compiler]:
    # Space for future expansion
    return lookup_gcc_like_compilers(arch)


def herdtools_backend_stanzas(
    cmd: str, style: str
) -> typing.Iterator[typing.Tuple[str, Backend]]:
    yield (cmd, Backend(cmd=cmd, style=style))


def lookup_herdtools_backend(cmd: str, style: str) -> typing.Mapping[str, Backend]:
    """Tests to see if the named Herdtools-style backend exists.
    If so, emits a dictionary containing one or more stanzas for it.
    If not, emits an empty dictionary.
    """
    return (
        dict(herdtools_backend_stanzas(cmd, style))
        if command_works(cmd, "-version")
        else {}
    )


def lookup_herdtools_backends() -> typing.Mapping[str, Backend]:
    return collections.ChainMap(
        *(
            lookup_herdtools_backend(cmd, style)
            for (style, cmds) in herdtools_backends.items()
            for cmd in cmds
        )
    )


def lookup_local_backends() -> typing.Mapping[str, Backend]:
    # Space for future expansion
    return lookup_herdtools_backends()


def lookup_local_machine() -> Machine:
    """Looks up compilers and backends on this machine.

    :return: A `Machine` with the identifier "localhost", and any found
    compilers and backends on the local machine.
    """
    arch = platform.machine()

    compilers: typing.Mapping[str, Compiler] = lookup_local_compilers(arch)
    backends: typing.Mapping[str, Backend] = lookup_local_backends()

    return Machine("localhost", arch, compilers, backends)


def print_default(mach: Machine) -> None:
    print("default {")
    print(f"    try machine {mach.id}")
    print("}")


if __name__ == "__main__":
    mach: Machine = lookup_local_machine()
    mach.print()
    print()
    print_default(mach)
