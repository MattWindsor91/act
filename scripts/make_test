#!/usr/bin/env python3
# The Automagic Compiler Tormentor
#
# Copyright (c) 2018--2019 Matt Windsor and contributors
#
# ACT itself is licensed under the MIT License. See the LICENSE file in the
# project root for more information.
#
# ACT is based in part on code from the Herdtools7 project
# (https://github.com/herd/herdtools7) : see the LICENSE.herd file in the
# project root for more information.
"""Generates a test JSON file to use with the 'run_test' script."""

import argparse
import os
import pathlib
import sys
import typing

from act_py import act_id, machine_info, str_utils, test, test_common

# TODO(@MattWindsor91): understand backends other than machine.litmus.

drivers: typing.Mapping[str, typing.List[str]] = {
    "c_litmus":
      ["-b", '"{backend}"', '-c', '"{compiler}"', '-d', '"{dir}"', "{subject_path}"],
    "c_litmus_indirect":
      ["-b", '"{backend}"', '-c', '"{compiler}"', '-n', '"{subject_name}"', '-d', "{dir}", "{subject_path}"]
}

default_driver: str = "c_litmus_indirect"


def make_driver(name: str, argv: typing.List[str]) -> str:
    full_name = os.path.join(os.path.dirname(__file__), name)
    return " ".join([full_name, *argv])


def get_driver(name: str) -> str:
    argv: typing.List[str]
    try:
        argv = drivers[name]
    except KeyError:
        print(f"No such driver: {name}, using {default_driver} instead.", file=sys.stderr)
        argv = drivers[default_driver]
    return make_driver(name, argv)


def make_test(
    output_dir: pathlib.Path,
    subject_paths: typing.List[pathlib.Path],
    machine_predicate: typing.Optional[str],
    compiler_predicate: typing.Optional[str],
    driver_name: str
) -> test.Test:
    subjects = [inspect_subject(path) for path in subject_paths]

    driver: str = get_driver(driver_name)
    env: test_common.Env = test_common.Env(subjects, driver, output_dir)
    machines: typing.Mapping[act_id.Id, test.MachineTest] = get_machines(
        compiler_predicate=compiler_predicate, machine_predicate=machine_predicate
    )
    return test.Test(env, machines)


def inspect_subject(path: pathlib.Path) -> test_common.Subject:
    """Visits the subject path `path` and infers the rest of the subject data.

    :param path: The path to visit.
    :return: The resulting `test_runner.TestSubject`.
    """
    with open(path, "r") as fp:
        name: str = get_subject_name(path, fp)
    return test_common.Subject(name, path)


def get_subject_name(path: os.PathLike, fp: typing.TextIO) -> str:
    """Reads the subject name from the top of a Litmus test.

    :param path:
        The path to the file being read, used for any exceptions.
    :param fp:
        The file pointer to read.
    :return:
        The name mentioned in the header of the Litmus test.
    """
    fp.seek(0)
    header: str = fp.readline()
    header_chunks = header.split()
    if len(header_chunks) < 2:
        raise BadLitmusException(path, f"Header ill-formed: '{header}'")
    return header_chunks[1].strip()


class BadLitmusException(Exception):
    """Exception thrown when something occurs that indicates that a bad
    Litmus test was passed in."""

    def __init__(self, path: os.PathLike, message: str):
        super().__init__(f"Bad litmus file '{path}': {message}")


def get_machines(
    machine_predicate: typing.Optional[str], compiler_predicate: typing.Optional[str]
) -> typing.Mapping[act_id.Id, test.MachineTest]:
    """Gets machine information from ACT's configuration in `test_runner.MachineTest` form.

    :param machine_predicate:
        An optional S-expression representing the machine filtering predicate
        to use.
    :param compiler_predicate:
        An optional S-expression representing the compiler filtering predicate
        to use.
    :return: The captured machines.
    """
    raw_machines = machine_info.get_machines(
        compiler_predicate=compiler_predicate, machine_predicate=machine_predicate
    )
    return {k: expand_machine(k, compilers) for k, compilers in raw_machines.items()}


def expand_machine(
    machine_id: act_id.Id, compilers: typing.Iterable[act_id.Id]
) -> test.MachineTest:
    """Expands a raw machine listing into a testable machine.

    :param machine_id: The ID of the machine to expand.
    :param compilers: The machine to expand.
    :return: The result of expanding `raw_machine`.
    """
    backend = machine_info.get_backend_for(machine_id, style_id="litmus")
    return test.MachineTest(list(compilers), backend)


def sanitise_predicate(pred: str) -> str:
    return str_utils.with_default_if_blank(pred, default="true")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-o",
        "--output",
        metavar="DIR",
        type=lambda x: pathlib.Path(x),
        default=pathlib.Path("./output"),
        help="The directory to which the test will output its results.",
    )
    parser.add_argument(
        "-m",
        "--machines",
        dest="machine_predicate",
        metavar="SEXP",
        type=str,
        help="A filtering predicate to use to restrict the machines under test.",
    )
    parser.add_argument(
        "-c",
        "--compilers",
        dest="compiler_predicate",
        metavar="SEXP",
        type=str,
        help="A filtering predicate to use to restrict the compilers under test.",
    )
    parser.add_argument(
        "-d",
        "--driver",
        dest="driver_name",
        metavar="NAME",
        type=str,
        default=default_driver,
        help="The name of the driver (eg 'c_litmus', 'c_litmus_indirect') to use.",
    )
    parser.add_argument(
        "subjects",
        metavar="FILE",
        type=(lambda x: pathlib.Path(x)),
        nargs="+",
        help="The C/litmus files to test.",
    )
    args = parser.parse_args()

    result: test.Test = make_test(
        output_dir=args.output,
        subject_paths=args.subjects,
        compiler_predicate=sanitise_predicate(args.compiler_predicate),
        machine_predicate=sanitise_predicate(args.machine_predicate),
        driver_name=str_utils.with_default_if_blank(args.driver_name, default=default_driver)
    )
    result.dump(sys.stdout)
