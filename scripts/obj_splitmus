#!/usr/bin/env bash
#
# A driver that works by running Litmus on a stubbed-out version of
# a litmus test in cross-compile mode, then generates an object file
# containing the body of the litmus test and links it into the
# Litmus harness.

set -o errexit
set -o pipefail
set -o nounset

SCRIPTDIR="${SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"}"
readonly SCRIPTDIR

# shellcheck source=scripts/act_bash/exec.sh
source "${SCRIPTDIR}/act_bash/exec.sh"
# shellcheck source=scripts/act_bash/exec.sh
source "${SCRIPTDIR}/act_bash/log.sh"


## Constants and arguments ##


# The `sed` binary to use; this can be overrode using shell/environment variables.
SED=${SED="sed"}

# The backend ID to use to get state sets.
# Must not be empty at the end of argument parsing.
BACKEND="litmus7"

# The name of the compiler to compile through (using obj_splitmus).
# Must not be empty at the end of argument parsing.
COMPILER=""

# Whether or not we're running ACT programs through `dune exec`.
DUNE_EXEC="false"

# The path to the C Litmus test being used as a subject.
INPUT_FILE=""

# The directory to which we will output intermediate results.
# If empty, we construct a temporary directory.
OUTPUT_DIR=""

# The name to give to the Litmus test.
# If empty, we extract one from the input file.
TEST_NAME=""

# Whether or not verbose logging is enabled.
VERBOSE="false"


## Functions ##


# Runs the delitmusifier and compiler on an input litmus test, saving an
# aux file and header file for future consumption.
#
# Globals:
#   - ACT_C (read)
#   - SCRIPTDIR (read)
#
# Arguments:
#   1: the compiler ID.
#   2: path to the C litmus test to delitmusify and compile.
#   3: path to which a delitmus auxiliary file should be written.
#   4: path to which the intermediate C file should be written.
#   5: path to which a header file exposing the C file's functions should be written.
#   4: path to which the compiled object code should be written.
delitmus_and_compile() {
  local compiler="$1"
  local infile="$2"
  local auxfile="$3"
  local cfile="$4"
  local hfile="$5"
  local objfile="$6"

  act::delitmus -style vars-as-parameters -aux "${auxfile}" -o "${cfile}" "${infile}"
  act::compile -compiler "${compiler}" -mode object -o "${objfile}" "${cfile}"
  "${SCRIPTDIR}"/make_header.awk "${cfile}" > "${hfile}"
}


# Produces a ready-to-splice Litmus harness from a delitmus aux file.
#
# Globals:
#   - LITMUS (read)
#   - SCRIPTDIR (read)
#   - Various globals read by the scripts in `act_bash/exec.sh`
#
# Arguments:
#   1: the backend ID.
#   2: the compiler ID.
#   3: path to the delitmus aux file to use when generating the harness.
#   4: path to which a skeleton assembly file should be written.
#   5: path to which a skeleton assembly Litmus test should be written.
#   6: directory into which the Litmus harness should be constructed.
make_litmus_harness() {
  local backend="$1"
  local compiler="$2"
  local auxfile="$3"
  local skelfile="$4"
  local alitfile="$5"
  local litdir="$6"

  "${SCRIPTDIR}/gen_asm_skel.py" "${auxfile}" > "${skelfile}"
  act::litmusify -compiler "${compiler}" -aux "${auxfile}" -o "${alitfile}" "${skelfile}"
  # TODO(@MattWindsor91): store the outputted commands somewhere and run them
  act::backend make-harness -sim "${backend}" "${alitfile}" -output "${litdir}" > /dev/null
}


# Splices function calls corresponding to an object-file test candidate into a
# Litmus harness.  The object file, and its corresponding header, must be
# called 'body'.
#
# Globals:
#   - SCRIPTDIR (read)
#   - SED (read)
#
# Arguments:
#   1: path to the delitmus aux file to use when generating the harness.
#   2: path to the Litmus harness Makefile.
#   3: path to the Litmus harness's main .c file.
#   4: path to which a function call stub file should be written.
splice_litmus() {
  local auxfile="$1"
  local makefile="$2"
  local runfile="$3"
  local stubfile="$4"

  "${SCRIPTDIR}/gen_call_stubs.py" "${auxfile}" > "${stubfile}"
  "${SCRIPTDIR}"/splice.awk "${stubfile}" "${runfile}" > "${runfile}.new"
  mv "${runfile}.new" "${runfile}"

  # shellcheck disable=SC1004
  "${SED}" '
    /#include "utils.h"/ a\
    #include "body.h"
  ' "${runfile}" > "${runfile}.new"
  mv "${runfile}.new" "${runfile}"

  "${SED}" "s/UTILS=/UTILS=body.o /" "${makefile}" > "${makefile}.new"
  mv "${makefile}.new" "${makefile}"
}


# Runs the obj_splitmus driver once all arguments are parsed.
#
# Globals:
#   - OUTPUT_DIR (read)
#   - TEST_NAME (read)
run() {
  local auxfile="${OUTPUT_DIR}/${TEST_NAME}.aux.json"
  local cfile="${OUTPUT_DIR}/${TEST_NAME}.c"
  local stubfile="${OUTPUT_DIR}/${TEST_NAME}.stubs.c"
  local skelfile="${OUTPUT_DIR}/${TEST_NAME}.skel.s"
  local alitfile="${OUTPUT_DIR}/${TEST_NAME}.litmus"

  local litdir="${OUTPUT_DIR}/exec"
  mkdir -p "${litdir}"

  local runfile="${litdir}/${TEST_NAME}.c"

  # TODO(@MattWindsor91): what if $TEST_NAME is body?
  local objfile="${litdir}/body.o"
  local hfile="${litdir}/body.h"

  local makefile="${litdir}/Makefile"

  delitmus_and_compile "${COMPILER}" "${INPUT_FILE}" "${auxfile}" "${cfile}" "${hfile}" "${objfile}"
  make_litmus_harness "${BACKEND}" "${COMPILER}" "${auxfile}" "${skelfile}" "${alitfile}" "${litdir}"
  splice_litmus "${auxfile}" "${makefile}" "${runfile}" "${stubfile}"

  (cd "${litdir}" && make >/dev/null)
  "${litdir}/${TEST_NAME}.exe" | act::backend parse -sim "${BACKEND}"
}


# Prints the script's usage and exits.
usage() {
  echo "usage: $0 -b BACKEND_ID -c COMPILER_ID [-d DIR] [-n NAME] [-qvxh?] FILE" >&2
  echo
  echo "-b: ID of Litmus-style ACT backend to use for making harnesses"
  echo "-c: ID of compiler to use to compile file"
  echo "-d: directory to use for outputting intermediate files"
  echo "-n: name to use for Litmus test"
  echo "-v/-q: verbose/quiet"
  echo '-x: run ACT binaries with `dune exec`'
  echo "-h/-?: usage"
  exit 1
}


# Main function.
main() {
  while getopts "b:c:d:n:qvx?h" a; do
    case ${a} in
    b) BACKEND=${OPTARG} ;;
    c) COMPILER=${OPTARG} ;;
    d) OUTPUT_DIR=${OPTARG} ;;
    n) TEST_NAME=${OPTARG} ;;
    q) VERBOSE="false" ;;
    v) VERBOSE="true" ;;
    x) DUNE_EXEC="true" ;;
    h|?) usage ;;
    esac
  done
  readonly BACKEND COMPILER VERBOSE DUNE_EXEC
  shift $((OPTIND-1))

  if [[ -z ${BACKEND} ]]; then
    act::error "expected a nonempty backend (-b)"
    usage
  fi
  if [[ -z ${COMPILER} ]]; then
    act::error "expected a nonempty compiler (-c)"
    usage
  fi

  if [[ $# -ne 1 ]]; then
    act::error "expected precisely one anonymous argument"
    usage
  fi
  INPUT_FILE="$1"
  if [[ -z ${TEST_NAME} ]]; then
    TEST_NAME="$("${SCRIPTDIR}/litmus_test_name" "${INPUT_FILE}")"
    act::log "auto-naming test: '%s'.\n" "${TEST_NAME}"
  fi
  readonly INPUT_FILE TEST_NAME
  
  if [[ -z ${OUTPUT_DIR} ]]; then
    OUTPUT_DIR="$(mktemp -d)" || exit 2 
    act::log "using temporary directory: '%s'.\n" "${OUTPUT_DIR}"
    trap "rm -rf ${OUTPUT_DIR}" EXIT
  fi
  readonly OUTPUT_DIR

  if [[ ${DUNE_EXEC} = "true" ]]; then
    act::log "%s: using 'dune exec' for ACT.\n" "$0"
  fi

  run
}

## Entry point ##
main "$@"
