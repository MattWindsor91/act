#!/usr/bin/env bash
#
# A harness script that runs fuzz_many on the given filenames, then
# creates and runs a test in a possibly-given directory.

set -o errexit
set -o pipefail
set -o nounset

SCRIPTDIR="${SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"}"
# shellcheck source=scripts/act_bash/args.sh
source "${SCRIPTDIR}/act_bash/args.sh"
# shellcheck source=scripts/act_bash/exec.sh
source "${SCRIPTDIR}/act_bash/exec.sh"
# shellcheck source=scripts/act_bash/log.sh
source "${SCRIPTDIR}/act_bash/log.sh"
# shellcheck source=scripts/act_bash/naming.sh
source "${SCRIPTDIR}/act_bash/naming.sh"

## Constants ##

# The number of times each input should be fuzzed by default.
readonly DEFAULT_FUZZ_PASSES=10


readonly FUZZ_OUTPUT_DIR="fuzz"


readonly TEST_OUTPUT_DIR="test"


## Arguments ##


# Flags forwarded directly to the test checker.
CHECK_FLAGS=""

# Whether we are using Dune to execute any OCaml ACT tools.
DUNE_EXEC="false"

# The output directory used for both fuzzing and testing.
# If empty, this will be set by `act::setup_temp_output_dir`, and automatically
# removed on exit.
OUTPUT_DIR=""

# The number of times the fuzzer should run on each Memalloy output.
# Defaults to `DEFAULT_FUZZ_PASSES` if empty.
FUZZ_PASSES=""

# The compiler-filtering predicate to send to the test builder.
COMPILER_PREDICATE=""

# The machine-filtering predicate to send to the test builder.
MACHINE_PREDICATE=""


## Functions ##


# Prints usage information and exits.
usage() {
  echo "Usage: $0 [-c COMPILER_PREDICATE] [-m MACHINE_PREDICATE] [-k NUM_FUZZ_PASSES] [-qvxh?] MEMALLOY_DIR"
  echo
  echo "-c: ID of compiler to use (if given, obj_splitmus is used)"
  echo "-m: ID of backend to use for checking C files"
  echo "-k: number of times to fuzz each item"
  echo "-v/-q: verbose/quiet"
  echo "-x: run ACT binaries with \`dune exec\`"
  echo "-h/-?: usage"
  exit
}


# Main function.
main() {
  while getopts "c:d:k:m:suwtnSUWTNqvx?h" a; do
    case ${a} in
    c) COMPILER_PREDICATE=${OPTARG} ;;
    d) OUTPUT_DIR=${OPTARG} ;;
    k) FUZZ_PASSES=${OPTARG} ;;
    m) MACHINE_PREDICATE=${OPTARG} ;;
    s|u|w|t|n|S|U|W|T|N) CHECK_FLAGS="${CHECK_FLAGS}${a}" ;;
    q) VERBOSE="false" ;;
    v) VERBOSE="true" ;;
    x) DUNE_EXEC="true" ;;
    h|?) usage ;;
    esac
  done
  if [[ -z "${FUZZ_PASSES}" ]]; then FUZZ_PASSES="${DEFAULT_FUZZ_PASSES}"; fi
  readonly CHECK_FLAGS COMPILER_PREDICATE MACHINE_PREDICATE FUZZ_PASSES DUNE_EXEC VERBOSE
  shift $((OPTIND-1))

  if [[ ${DUNE_EXEC} = "true" ]]; then
    act::log "%s: using 'dune exec' for ACT.\n" "$0"
  fi

  if [[ -z ${OUTPUT_DIR} ]]; then act::setup_temp_output_dir; fi
  readonly OUTPUT_DIR

  # Flags used to communicate verbosity/dune-exec to other scripts.
  local qv_flags
  qv_flags="$(act::flags_qv)"
  local qvx_flags
  qvx_flags="$(act::flags_qvx)"

  local fuzz_dir="${OUTPUT_DIR}/${FUZZ_OUTPUT_DIR}"
  act::log "now fuzzing into %s\n" "${fuzz_dir}"
  mkdir -p "${fuzz_dir}"
  "${SCRIPTDIR}/fuzz_many" "${qvx_flags}" -c "${FUZZ_PASSES}" -d "${fuzz_dir}" "$@"


  local test_dir="${OUTPUT_DIR}/${TEST_OUTPUT_DIR}"
  local test_file="${test_dir}/test.json"
  act::log "now making test (%s)\n" "${test_file}"
  mkdir -p "${test_dir}"
  "${SCRIPTDIR}/make_test" -o "${test_dir}" --compilers="${COMPILER_PREDICATE}" --machines="${MACHINE_PREDICATE}" "${fuzz_dir}"/* > "${test_file}"

  if [[ ${VERBOSE} = "true" ]]; then echo_test_file "${test_file}"; fi

  act::log "now running test (%s)\n" "${test_file}"
  "${SCRIPTDIR}/run_test" "${qv_flags}" "${test_file}"
  "${SCRIPTDIR}/report_test" "${qv_flags}${CHECK_FLAGS}" "${test_file}"
}

# Dumps the contents of the given test file to stderr.
#
# Arguments:
#   1: the path to the test file
echo_test_file() {
  local test_file=$1

  echo "== BEGIN TEST FILE ==" >&2
  cat "${test_file}" >&2
  echo "" >&2
  echo "== END TEST FILE ==" >&2
}

## Entry point ##
main "$@"
