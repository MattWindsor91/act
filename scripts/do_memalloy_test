#!/usr/bin/env bash
#
# A harness script that runs memalloy (looking for it in the given directory),
# fuzzes its output into a directory, builds a test, runs that test, and
# handles the results.

set -o errexit
set -o pipefail
set -o nounset

SCRIPTDIR="${SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"}"
# shellcheck source=scripts/act_bash/args.sh
source "${SCRIPTDIR}/act_bash/args.sh"
# shellcheck source=scripts/act_bash/exec.sh
source "${SCRIPTDIR}/act_bash/exec.sh"
# shellcheck source=scripts/act_bash/log.sh
source "${SCRIPTDIR}/act_bash/log.sh"

## Constants ##
# TODO(@MattWindsor91): most of these shouldn't be hardcoded.

# The number of events Memalloy should be asked to produce by default.
readonly DEFAULT_MEMALLOY_EVENTS=4

# The number of times the fuzzer should run on each Memalloy output by default.
readonly DEFAULT_FUZZ_PASSES=10

# The directory, relative to the Memalloy output directory, to which any
# fuzzer outcomes should be output.
readonly FUZZ_OUTPUT_DIR="fuzz"

## Arguments ##


# Flags forwarded directly to the test checker.
CHECK_FLAGS=""

# Whether we are using Dune to execute any OCaml ACT tools.
DUNE_EXEC="false"

# Whether we are forcing Memalloy to run even if we have a results directory.
FORCE_MEMALLOY="false"

# The directory in which Memalloy lives.
MEMALLOY_DIR=""

# The number of events to ask Memalloy to generator
# Defaults to `DEFAULT_MEMALLOY_EVENTS` if empty.
MEMALLOY_EVENTS=""

# The number of times the fuzzer should run on each Memalloy output.
# Defaults to `DEFAULT_FUZZ_PASSES` if empty.
FUZZ_PASSES=""

# The compiler-filtering predicate to send to the test builder.
COMPILER_PREDICATE=""

# The machine-filtering predicate to send to the test builder.
MACHINE_PREDICATE=""

## Functions ##


# Prints usage information and exits.
usage() {
  echo "Usage: $0"
  echo "  [-c COMPILER_PREDICATE] [-m MACHINE_PREDICATE]"
  echo "  [-e NUM_MEMALLOY_EVENTS] [-k NUM_FUZZ_PASSES]"
  echo "  [-fsuwtnSUWTNqvxh?] MEMALLOY_DIR"
  exit
}


# Main function.
main() {
  while getopts "c:e:k:m:fsuwtnSUWTNqvx?h" a; do
    case ${a} in
    c) COMPILER_PREDICATE=${OPTARG} ;;
    e) MEMALLOY_EVENTS=${OPTARG} ;;
    k) FUZZ_PASSES=${OPTARG} ;;
    m) MACHINE_PREDICATE=${OPTARG} ;;
    s|u|w|t|n|S|U|W|T|N) CHECK_FLAGS="${CHECK_FLAGS}${a}" ;;
    f) FORCE_MEMALLOY="true" ;;
    q) VERBOSE="false" ;;
    v) VERBOSE="true" ;;
    x) DUNE_EXEC="true" ;;
    h|?) usage ;;
    esac
  done
  readonly CHECK_FLAGS COMPILER_PREDICATE MACHINE_PREDICATE MEMALLOY_EVENTS \
	   FUZZ_PASSES FORCE_MEMALLOY DUNE_EXEC VERBOSE
  shift $((OPTIND-1))

  if [[ ${DUNE_EXEC} = "true" ]]; then
    act::log "%s: using 'dune exec' for ACT.\n" "$0"
  fi

  if [[ $# -ne 1 ]]; then
    act::error "need precisely one directory"
    usage
  fi
  readonly MEMALLOY_DIR=$1

  run_memalloy_if_needed
  run_fuzz_and_test
}


# Checks whether Memalloy forcing is on, or if the results directory is
# not present.  If either are true, runs `do_memalloy` in the specified
# Memalloy directory.
#
# If we are reusing the existing Memalloy directory, and verbosity is on,
#
# Globals:
#   FORCE_MEMALLOY: read
#   MEMALLOY_DIR: read
#   MEMALLOY_EVENTS: read
#   SCRIPTDIR: read
#   VERBOSE: read indirectly
run_memalloy_if_needed() {
  local results_dir="${MEMALLOY_DIR}/results/_latest"

  if [[ ${FORCE_MEMALLOY} == "true" || ( ! -d "${results_dir}" ) ]]; then
    act::log "Running memalloy.\n"
    "${SCRIPTDIR}/do_memalloy" -e "${MEMALLOY_EVENTS}" "${MEMALLOY_DIR}"
  else
    act::log "Using existing memalloy results directory"
    dump_last_modified_time "${results_dir}"
    act::log ".\n"
  fi

  if [[ ! -d "${results_dir}" ]]; then
    act::error "Missing Memalloy results directory"
    exit
  fi
}


# If `stat` is available, prints the last modified time of the given results
# directory symlink (less a newline).
#
# Arguments:
#   1: the results-directory symlink to inspect.
dump_last_modified_time() {
  local results_dir=$1

  # `stat` is non-standard: if it exists, it'll have different flags depending
  # on whether we're on a GNU or BSD system (or, indeed, a non-GNU non-BSD
  # system, but we don't support that yet).  The other thing is that `printf`
  # has different format flags!
  if [[ -z $(command -v stat)  ]]; then return 1; fi
  case "$(uname -s)" in
    Linux)
      # GNU stat and printf
      local mtime="$(stat -Lc "%Y" "${results_dir}")"
      act::log " (last modified on %(%c)T)" "${mtime}"
      ;;
    Darwin|NetBSD|OpenBSD)
      # BSD stat and printf
      local mtime="$(stat -Lf "%Sm" "${results_dir}")"
      act::log " (last modified on %s)" "${mtime}"
      ;;
    *) return 2 ;;
  esac
}

# Runs the `fuzz_and_test` script on the results produced by the last
# invocation of Memalloy.
#
# Globals:
#   CHECK_FLAGS: read
#   COMPILER_PREDICATE: read
#   DUNE_EXEC: read indirectly
#   FUZZ_PASSES: read
#   MACHINE_PREDICATE: read
#   MEMALLOY_DIR: read
#   SCRIPTDIR: read
run_fuzz_and_test() {
  local results_dir="${MEMALLOY_DIR}/results/_latest"
  local litmus_dir="${results_dir}/litmus"

  local scratch_dir="${results_dir}/act"
  mkdir -p "${scratch_dir}"

  local qvx_flags
  qvx_flags="$(act::flags_qvx)"

  "${SCRIPTDIR}/fuzz_and_test" \
    -c "${COMPILER_PREDICATE}" \
    -d "${scratch_dir}" \
    -k "${FUZZ_PASSES}" \
    -m "${MACHINE_PREDICATE}" \
    "${qvx_flags}${CHECK_FLAGS}" \
    "${litmus_dir}"/*.litmus
}


## Entry point ##
main "$@"
