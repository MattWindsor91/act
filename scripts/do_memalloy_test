#!/usr/bin/env bash
#
# A harness script that runs memalloy (looking for it in the given directory),
# fuzzes its output into a directory, builds a test, runs that test, and
# handles the results.

set -o errexit
set -o pipefail
set -o nounset

SCRIPTDIR="${SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"}"
# shellcheck source=scripts/act_bash/args.sh
source "${SCRIPTDIR}/act_bash/args.sh"
# shellcheck source=scripts/act_bash/exec.sh
source "${SCRIPTDIR}/act_bash/exec.sh"
# shellcheck source=scripts/act_bash/log.sh
source "${SCRIPTDIR}/act_bash/log.sh"

declare DEFAULT_MEMALLOY_EVENTS
# shellcheck source=scripts/act_bash/memalloy.sh
source "${SCRIPTDIR}/act_bash/memalloy.sh"

## Arguments ##


# Flags forwarded directly to the test checker.
CHECK_FLAGS=""

# The compiler-filtering predicate to send to the test builder.
COMPILER_PREDICATE=""

# Whether we are using Dune to execute any OCaml ACT tools.
DUNE_EXEC="false"

# Whether we are forcing Memalloy to run even if we have a results directory.
FORCE_MEMALLOY="false"

# The number of times the fuzzer should run on each Memalloy output.
# Defaults to `DEFAULT_FUZZ_PASSES` if empty.
FUZZ_PASSES=""

# The machine-filtering predicate to send to the test builder.
MACHINE_PREDICATE=""

# The directory in which Memalloy lives.
MEMALLOY_DIR=""

# The number of events to ask Memalloy to generator
# Defaults to `DEFAULT_MEMALLOY_EVENTS` if empty.
MEMALLOY_EVENTS=""

# Whether or not verbose logging is enabled.
VERBOSE="false"


## Functions ##


# Prints usage information and exits.
usage() {
  echo "Usage: $0"
  echo "  [-c COMPILER_PREDICATE] [-m MACHINE_PREDICATE]"
  echo "  [-e NUM_MEMALLOY_EVENTS] [-k NUM_FUZZ_PASSES]"
  echo "  [-fsuwtnSUWTNqvxh?] MEMALLOY_DIR"
  echo
  echo "-e: number of events for Memalloy to produce (default ${DEFAULT_MEMALLOY_EVENTS})"
  echo "-k: number of times each Memalloy output will be fuzzed"
  echo "-h/-?: usage"
  exit
}


# Main function.
main() {
  while getopts "c:e:k:m:fsuwtnSUWTNqvx?h" a; do
    case ${a} in
    c) COMPILER_PREDICATE=${OPTARG} ;;
    e) MEMALLOY_EVENTS=${OPTARG} ;;
    k) FUZZ_PASSES=${OPTARG} ;;
    m) MACHINE_PREDICATE=${OPTARG} ;;
    s|u|w|t|n|S|U|W|T|N) CHECK_FLAGS="${CHECK_FLAGS}${a}" ;;
    f) FORCE_MEMALLOY="true" ;;
    q) VERBOSE="false" ;;
    v) VERBOSE="true" ;;
    x) DUNE_EXEC="true" ;;
    h|?) usage ;;
    esac
  done
  readonly CHECK_FLAGS COMPILER_PREDICATE MACHINE_PREDICATE MEMALLOY_EVENTS \
	   FUZZ_PASSES FORCE_MEMALLOY DUNE_EXEC VERBOSE
  shift $((OPTIND-1))

  act::check_dune_exec

  if [[ $# -ne 1 ]]; then act::arg_error "need precisely one directory"; fi
  readonly MEMALLOY_DIR=$1

  local results_dir="${MEMALLOY_DIR}/results/_latest"
  local scratch_dir="${results_dir}/act"
  local dnf_dir="${scratch_dir}/dnf"

  local flags
  flags="$(act::flags_qvx)"
  if [[ ${FORCE_MEMALLOY} = "true" ]]; then flags="${flags}f"; fi

  "${SCRIPTDIR}/do_memalloy_dnf" "${flags}" -e "${MEMALLOY_EVENTS}" "${MEMALLOY_DIR}" "${dnf_dir}"

  run_fuzz_and_test "${dnf_dir}" "${scratch_dir}"
}


# Runs the `fuzz_and_test` script on the results produced by the last
# invocation of Memalloy.
#
# Globals:
#   CHECK_FLAGS: read
#   COMPILER_PREDICATE: read
#   DUNE_EXEC: read indirectly
#   FUZZ_PASSES: read
#   MACHINE_PREDICATE: read
#   MEMALLOY_DIR: read
#   SCRIPTDIR: read
#
# Arguments:
#   1: the directory to use for input (should contain '.litmus' files)
#   2: the root output directory
run_fuzz_and_test() {
  local input_dir="${1}"
  local output_dir="${2}"

  local qvx_flags
  qvx_flags="$(act::flags_qvx)"

  "${SCRIPTDIR}/fuzz_and_test" \
    -c "${COMPILER_PREDICATE}" \
    -d "${output_dir}" \
    -k "${FUZZ_PASSES}" \
    -m "${MACHINE_PREDICATE}" \
    "${qvx_flags}${CHECK_FLAGS}" \
    "${input_dir}"/*.litmus
}


## Entry point ##
main "$@"
