(* The Automagic Compiler Tormentor

   Copyright (c) 2018, 2019, 2020 Matt Windsor and contributors

   ACT itself is licensed under the MIT License. See the LICENSE file in the
   project root for more information.

   ACT is based in part on code from the Herdtools7 project
   (https://github.com/herd/herdtools7) : see the LICENSE.herd file in the
   project root for more information. *)

open Base
open Import

open struct
  type env = Fir.Env.t

  type t = Fir.Expression.t
end

(** [kbop k in_type] tries to make a generator for binary operations that
    have operands of value type [in_type], but result in [k]. *)
let kbop (k : Fir.Constant.t) ~(in_type : Fir.Type.Prim.t) :
    (Op.Operand_set.t -> t Q.Generator.t) option =
  (* TODO(@MattWindsor91): make sure the type is right. *)
  Op.bop_with_output
    ~ops:(Fir.Op.Binary.of_input_prim_type in_type)
    (Const k)

let ibop (t : Fir.Type.Prim.t) : (Op.Operand_set.t -> t Q.Generator.t) option
    =
  (* There is always at least one Idem operator: for example, bitwise OR for
     integers and logical OR for Booleans. *)
  Op.bop_with_output ~ops:(Fir.Op.Binary.of_input_prim_type t) Idem

(** [arb_bop ~gen_arb ~bop] generates binary operations of the form
    [x op x], [x op k2], or [k2 op x], where [x] is an arbitrary expression
    generated by [gen_arb], [k2] is a specific constant, and the resulting
    operation is known to produce the wanted constant. *)
let arb_bop ~(gen_arb : t Q.Generator.t)
    ~(bop : Op.Operand_set.t -> t Q.Generator.t) : t Q.Generator.t =
  (* This is [kv_env] because it depends on the value not changing between
     reading the LHS and reading the LHS. *)
  Q.Generator.(
    Let_syntax.(
      let%bind size = size in
      let%bind p = with_size ~size:(size / 2) gen_arb in
      bop (One p)))

(** [kv_bop ~gen_load ~bop] generates binary operations of the form
    [x op y], in which one of [x] and [y] is a variable, the other is its
    known value, and the operation is statically known to produce the wanted
    constant. *)
let kv_bop 
    ~(gen_load : (t * Fir.Env.Record.t) Q.Generator.t)
    ~(bop : Op.Operand_set.t -> t Q.Generator.t) : t Q.Generator.t =
      Expr_util.gen_kv_refl ~gen_load ~gen_op:(fun l r -> bop (Two (l, r)))

let base_generators (k : Fir.Constant.t) : (float * t Q.Generator.t) list =
  (* TODO(@MattWindsor91): known values of kv_env variables *)
  [(1.0, Q.Generator.return (Fir.Expression.constant k))]

let recursive_generators
    ?(ibop : (Op.Operand_set.t -> t Q.Generator.t) option)
    ?(int_kbop : (Op.Operand_set.t -> t Q.Generator.t) option)
    ?(bool_kbop : (Op.Operand_set.t -> t Q.Generator.t) option)
    (mu : t Q.Generator.t) ~(int : t Q.Generator.t)
    ~(bool : t Q.Generator.t)
    ~(int_load : (t * Fir.Env.Record.t) Q.Generator.t)
    ~(bool_load : (t * Fir.Env.Record.t) Q.Generator.t)
    ~(has_ints : bool)
    ~(has_bools : bool) :
    (float * t Q.Generator.t) list =
  let int_var_check = Option.some_if has_ints () in
  let bool_var_check = Option.some_if has_bools () in
  List.filter_opt
    [ Option.map int_kbop ~f:(fun bop ->
          (3.0, arb_bop ~gen_arb:int ~bop))
    ; Option.map bool_kbop ~f:(fun bop ->
          (3.0, arb_bop ~gen_arb:bool ~bop))
    ; Option.map2 int_kbop int_var_check ~f:(fun bop () ->
          (5.0, kv_bop ~gen_load:int_load ~bop))
    ; Option.map2 bool_kbop bool_var_check ~f:(fun bop () ->
          (5.0, kv_bop ~gen_load:bool_load ~bop))
    ; (* This should actually always resolve. *)
      Option.map ibop
        ~f:(fun bop ->
          ( 3.0
          , Q.Generator.Let_syntax.(
              let%bind x = mu and y = mu in
              bop (Two (x, y))) )) ]

let gen (k : Fir.Constant.t) (env : env) ~(int : env -> t Q.Generator.t)
    ~(bool : env -> t Q.Generator.t)
    ~(int_load : env -> (t * Fir.Env.Record.t) Q.Generator.t)
    ~(bool_load : env -> (t * Fir.Env.Record.t) Q.Generator.t) :
    t Q.Generator.t =
  let kv_env = Fir.Env.filter_to_known_values env in
  let has_ints = Fir.Env.has_vars_of_prim_type kv_env ~prim:Int in
  let has_bools = Fir.Env.has_vars_of_prim_type kv_env ~prim:Bool in
  let int = Q.Generator.of_lazy (lazy (int kv_env)) in
  let bool = Q.Generator.of_lazy (lazy (bool kv_env)) in
  let int_load = Q.Generator.of_lazy (lazy (int_load kv_env)) in
  let bool_load = Q.Generator.of_lazy (lazy (bool_load kv_env)) in
  let (* rec *) mu (k : Fir.Constant.t) = (
    let int_kbop = kbop k ~in_type:Int in
    let bool_kbop = kbop k ~in_type:Bool in
    let ibop = ibop (Fir.Constant.prim_type_of k) in
    Q.Generator.weighted_recursive_union (base_generators k)
        ~f:(recursive_generators ?ibop ?int_kbop ?bool_kbop ~int_load ~bool_load ~int ~bool ~has_ints ~has_bools)
  )
  in mu k
