(* The Automagic Compiler Tormentor

   Copyright (c) 2018--2019 Matt Windsor and contributors

   ACT itself is licensed under the MIT License. See the LICENSE file in the
   project root for more information.

   ACT is based in part on code from the Herdtools7 project
   (https://github.com/herd/herdtools7) : see the LICENSE.herd file in the
   project root for more information. *)

(** Fuzzer: subjects of fuzzing

    This module contains types for thread and litmus tests that are looser
    and lighter than their {!Act_fir} versions, and more suited to mutation.

    Many of these types take a metadata type parameter, but this is mostly
    just to support creating path types over them; in practice, the only
    metadata type used in the fuzzer is {!Metadata.t}. *)

open Base

(** {1 Shorthand for FIR constructs with subject metadata}

    Compared to the metadata-parametric forms in {!Act_fir}, these don't
    contain any accessors/constructors/traversals, but do group useful
    functionality that depends on knowing the metadata type.

    See also {!Label}. *)

(** {2 Subject statements} *)

module Statement : sig
  type t = Metadata.t Act_fir.Statement.t [@@deriving sexp]

  module If : sig
    type t = Metadata.t Act_fir.Statement.If.t [@@deriving sexp]
  end

  module Flow : sig
    type t = Metadata.t Act_fir.Statement.Flow_block.t [@@deriving sexp]
  end

  include Act_fir.Statement_types.S_with_meta with type t := t

  (** {3 Constructors} *)

  val make_generated_prim : Act_fir.Prim_statement.t -> t
  (** [make_generated_prim prim] lifts a primitive statement to a generated
      subject statement. *)

  (** {3 Statement predicates}

      If a predicate exists here instead of on {!Act_fir.Statement}, it
      depends on having fixed metadata in some way. *)

  val has_atomic_statements : t -> bool
  (** [has_atomic_statements stm] is true if there are atomic statements in
      [stm], looking recursively. *)

  val has_labels : t -> bool
  (** [has_labels stm] is true if there are labels in [stm], looking
      recursively. *)
end

(** {2 Subject blocks} *)

module Block : sig
  type t = (Metadata.t, Statement.t) Act_fir.Block.t

  (** {3 Specialised constructors}

      For normal constructors, see {!Act_fir.Block}. *)

  val make_existing : ?statements:Statement.t list -> unit -> t
  (** [make_existing ?statements ()] makes a block, optionally containing the
      existing statements [statements], that is metadata-marked as existing
      before fuzzing. *)

  val make_generated : ?statements:Statement.t list -> unit -> t
  (** [make_generated ?statements ()] makes a block, optionally containing
      the existing statements [statements], that is metadata-marked as
      generated by the fuzzer. *)

  val make_dead_code : ?statements:Statement.t list -> unit -> t
  (** [make_generated ?statements ()] makes a block, optionally containing
      the existing statements [statements], that is metadata-marked as
      generated and dead-code-by-construction by the fuzzer. *)
end

(** {1 Fuzzable representation of a thread} *)
module Thread : sig
  (** Transparent type of fuzzable programs. *)
  type t =
    { decls: Act_fir.Initialiser.t Act_common.C_named.Alist.t
    ; stms: Statement.t list }
  [@@deriving sexp]

  (** {2 Constructors} *)

  val empty : t
  (** [empty] is the empty program. *)

  val make :
       ?decls:Act_fir.Initialiser.t Act_common.C_named.Alist.t
    -> ?stms:Statement.t list
    -> unit
    -> t
  (** [make ?decls ?stms ()] makes a thread with the given decls and
      statements (defaulting to empty). *)

  val of_function : unit Act_fir.Function.t -> t
  (** [of_litmus func] converts a FIR C function [func] to the intermediate
      form used for fuzzing. *)

  (** {2 Manipulating threads} *)

  val map_decls :
       t
    -> f:
         (   Act_fir.Initialiser.t Act_common.C_named.t
          -> Act_fir.Initialiser.t Act_common.C_named.t)
    -> t
  (** [map_decls thd ~f] maps [f] over each decl in [thd]. *)

  val to_function :
       t
    -> vars:Var.Map.t
    -> id:int
    -> unit Act_fir.Function.t Act_common.C_named.t
  (** [to_function prog ~vars ~id] lifts a subject-program [prog] with ID
      [prog_id] back into a Litmus function, adding a parameter list
      generated from [vars] and erasing any metadata. *)

  val list_to_litmus :
    t list -> vars:Var.Map.t -> Act_fir.Litmus.Lang.Program.t list
  (** [list_to_litmus progs ~vars] lifts a list [progs] of subject-programs
      back into Litmus programs, adding parameter lists generated from
      [vars], and using the physical position of each program in the list to
      generate its thread ID. *)
end

(** Fuzzable representation of a litmus test. *)
module Test : sig
  (** Transparent type of fuzzable litmus tests. *)
  type t = (Act_fir.Constant.t, Thread.t) Act_litmus.Test.Raw.t
  [@@deriving sexp]

  val add_new_thread : t -> t
  (** [add_new_thread test] appends a new, empty thread onto [test]'s threads
      list, returning the resulting test. *)

  val of_litmus : Act_fir.Litmus.Test.t -> t
  (** [of_litmus test] converts a validated C litmus test [test] to the
      intermediate form used for fuzzing. *)

  val to_litmus : t -> vars:Var.Map.t -> Act_fir.Litmus.Test.t Or_error.t
  (** [to_litmus subject ~vars] tries to reconstitute a validated C litmus
      test from the subject [subject], using the variable map [vars] to
      reconstitute parameters. It may fail if the resulting litmus is
      invalid---generally, this signifies an internal error. *)

  (** {3 Availability queries} *)

  val has_statements_matching :
    t -> templates:Act_fir.Statement_class.t list -> bool
  (** [has_statements_matching test ~templates] is true if, and only if,
      [test] contains at least one statement matching one of [templates]. *)

  val has_statements_not_matching :
    t -> templates:Act_fir.Statement_class.t list -> bool
  (** [has_statements_not_matching test ~templates] is true if, and only if,
      [test] contains at least one statement not matching one of [templates]. *)

  val has_atomic_statements : t -> bool
  (** [has_atomic_statements test] is true if, and only if, [test] contains
      at least one atomic statement. *)

  val has_statements : t -> bool
  (** [has_statements test] is true if, and only if, [test] contains at least
      one statement. *)

  val has_if_statements : t -> bool
  (** [has_if_statements test] is true if, and only if, [test] contains at
      least one if statement. *)

  val has_while_loops : t -> bool
  (** [has_while_loops test] is true if, and only if, [test] contains at
      least one while loop. *)

  val has_dead_code_blocks : t -> bool
  (** [has_dead_code_blocks test] is true if, and only if, [test] contains at
      least one dead code block. *)

  val has_non_label_prims : t -> bool
  (** [has_non_label_prims test] is true if there is at least one primitive
      statement in [test] that is not a label. *)

  (** {3 Helpers for mutating tests} *)

  val declare_var :
    t -> Act_common.Litmus_id.t -> Act_fir.Initialiser.t -> t Or_error.t
  (** [declare_var subject var init] adds [var] with initialiser [init] to
      [subject]'s init block or thread initialisers with the initial value
      [initial_value]. *)
end
